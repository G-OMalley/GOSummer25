import pandas as pd
import numpy as np
from pathlib import Path
from datetime import datetime, timedelta
import json
import webbrowser
import time
import plotly.graph_objs as go
import plotly.colors

# --- Setup ---
# Determine the base directory of the script
script_dir = Path(__file__).parent

# The project root (e.g., 'trader-helper') is one level up from the script's directory.
project_root = script_dir.parent

# Define the base data folder relative to the project root
# This assumes your 'INFO' folder is directly under the 'trader-helper' root
data_folder = project_root / "INFO"

# Define the output path for the generated HTML report relative to the project root
# This assumes the HTML report should be generated directly in the 'trader-helper' root
output_path = project_root / "EIA_Dashboard.html" # Renamed for clarity

print(f"Data folder resolved to: {data_folder}")
print(f"Output path resolved to: {output_path}")

# Standard base temperature for CDD/HDD in natural gas markets
BASE_TEMP_CDD_HDD = 65

region_map = {
    "Lower 48 States Storage (Bcf)": "lower_48_states_storage",
    "East Region Storage (Bcf)": "east_region_storage",
    "Midwest Region Storage (Bcf)": "midwest_region_storage",
    "South Central Region Storage (Bcf)": "south_central_region_storage",
    "Salt Region SC Storage (Bcf)": "salt_region_sc_storage",
    "Nonsalt Region SC Storage (Bcf)": "nonsalt_region_sc_storage",
    "Mountain Region Storage (Bcf)": "mountain_region_storage",
    "Pacific Region Storage (Bcf)": "pacific_region_storage"
}
# DEFAULT_REGION_DISPLAY_NAME is now used as the fixed default for the Report tab.
DEFAULT_REGION_DISPLAY_NAME = "Lower 48 States Storage (Bcf)"

files = {
    "eia_totals": "EIAtotals.csv",
    "eia_changes": "EIAchanges.csv",
    "weather": "WEATHER.csv", # Keep for original dashboard weather
    "prices": "PRICES.csv", # Keep for original dashboard prices
    "fundy": "Fundy.csv",
    "forecast": "FundyForecast.csv",
    "criterion_storage_change": "CriterionStorageChange.csv",
    "nuclear_forecast": "NuclearForecast.csv",
}

# --- BASIS ANALYSIS SPECIFIC CONFIGURATION ---
PRICES_FILE_BASIS = data_folder / "PRICES.csv"
WEATHER_HISTORICAL_FILE_BASIS = data_folder / "WEATHER.csv"
WEATHER_FORECAST_FILE_BASIS = data_folder / "WEATHERforecast.csv"

HENRY_HUB_NAME = 'Henry' # The column name for Henry Hub in PRICES.csv

# --- City Name Standardization Map (for Basis Analysis and Weather Report) ---
CITY_STANDARDIZATION_MAP = {
    'JFK NY': 'John F. Kennedy NY',
    'Houston IAH TX': 'Houston TX',
    'Ok. City OK': 'Oklahoma City OK',
    'Chicago OHare IL': 'Chicago IL',
    'Washington DC': 'Washington National DC',
    'Ral-Durham NC': 'Raleigh/Durham NC',
    'Atlanta GA': 'Atlanta GA',
    'Boston MA': 'Boston MA',
    'Buffalo NY': 'Buffalo NY',
    'Denver CO': 'Denver CO',
    'Detroit MI': 'Detroit MI',
    'Los Angeles CA': 'Los Angeles CA',
    'Little Rock AR': 'Little Rock AR',
    'New Orleans LA': 'New Orleans LA',
    'Philadelphia PA': 'Philadelphia PA',
    'Pittsburgh PA': 'Pittsburgh PA',
    'Seattle WA': 'Seattle WA',
    'San Francisco CA': 'San Francisco CA',
    'Tampa FL': 'Tampa FL',
}

def standardize_city_name(city_name):
    """Applies a common standardization (strip) and then uses the hardcoded map."""
    city_name = str(city_name).strip() # Basic cleaning
    return CITY_STANDARDIZATION_MAP.get(city_name, city_name)

# --- Hardcoded Component to City Mapping (for Basis Analysis) ---
COMPONENT_TO_CITY_MAP_HARDCODED = {
    'AGT-CG (non-G)': 'John F. Kennedy NY',
    'ANR-SE-T': 'Houston TX',
    'ANR-SW': 'Oklahoma City OK',
    'APC-ACE': 'Chicago IL',
    'CG-Mainline': 'New Orleans LA',
    'CG-Onshore': 'New Orleans LA',
    'Carthage': 'Oklahoma City OK',
    'Chicago': 'Chicago IL',
    'Dracut': 'Boston MA',
    'Eastern Gas-South': 'Pittsburgh PA',
    'FGT-Z3': 'Tampa FL',
    'HSC-HPL Pool': 'Houston TX',
    'Henry': 'Henry Hub',
    'Iroquois (into)': 'Buffalo NY',
    'Iroquois-Z2': 'John F. Kennedy NY',
    'Leidy-Transco': 'Philadelphia PA',
    'Michcon': 'Detroit MI',
    'NBPL-Vector': 'Chicago IL',
    'NGPL-Midcont Pool': 'Oklahoma City OK',
    'NGPL-STX': 'Houston TX',
    'NGPL-TXOK East': 'Houston TX',
    'NNG-Demarc': 'Chicago IL',
    'NNG-Ventura': 'Chicago IL',
    'Panhandle': 'Oklahoma City OK',
    'Pine Prairie': 'Atlanta GA',
    'REX E-NGPL': 'Chicago IL',
    'REX-Z3 (receipt)': 'Philadelphia PA',
    'Sonat-Z0 South': 'Atlanta GA',
    'TCO': 'Pittsburgh PA',
    'TETCO-ELA': 'Houston TX',
    'TETCO-M2 (receipt)': 'Pittsburgh PA',
    'TETCO-M3': 'John F. Kennedy NY',
    'TETCO-STX': 'Houston TX',
    'TETCO-WLA': 'Houston TX',
    'TGP-500L': 'Houston TX',
    'TGP-800L': 'Houston TX',
    'TGP-Z0 South': 'Houston TX',
    'TGP-Z1 100L': 'Houston TX',
    'TGP-Z1 Sta-87': 'Houston TX',
    'TGP-Z4 Marcellus': 'Pittsburgh PA',
    'TGP-Z4 Sta-219': 'Pittsburgh PA',
    'TGP-Z4 Sta-313': 'Pittsburgh PA',
    'TGT-Mainline': 'Houston TX',
    'Transco Zn3': 'Atlanta GA',
    'Transco-165': 'Raleigh/Durham NC',
    'Transco-30': 'Houston TX',
    'Transco-45': 'Atlanta GA',
    'Transco-65': 'Atlanta GA',
    'Transco-85': 'Atlanta GA',
    'Transco-Z5 South': 'Washington National DC',
    'Transco-Z6 (NY)': 'John F. Kennedy NY',
    'Transco-Z6 (non-NY north)': 'Philadelphia PA',
    'Transco-Z6 (non-NY)': 'Philadelphia PA',
    'Transco-Z6 Sta-210': 'Philadelphia PA',
    'Trunkline-Z1A': 'Houston TX',
    'Union-Dawn': 'Buffalo NY',
    'Waha': 'Houston TX',
}

# --- New: Mapping storage regions to their corresponding weather cities (standardized names) ---
WEATHER_REGION_CITY_MAP = {
    "East Region Storage (Bcf)": [
        'Boston MA', 'Buffalo NY', 'John F. Kennedy NY', 'Philadelphia PA',
        'Pittsburgh PA', 'Washington National DC', 'Raleigh/Durham NC'
    ],
    "Midwest Region Storage (Bcf)": [
        'Chicago IL', 'Detroit MI'
    ],
    "South Central Region Storage (Bcf)": [
        'Little Rock AR', 'Houston TX', 'New Orleans LA', 'Oklahoma City OK', 'Atlanta GA'
    ],
    "Pacific Region Storage (Bcf)": [
        'Los Angeles CA', 'San Francisco CA', 'Seattle WA'
    ],
    # Assuming these map to specific cities for weather reporting based on common practice or data availability
    "Salt Region SC Storage (Bcf)": [
        'Houston TX', 'New Orleans LA' # Added more relevant cities for SC Salt
    ],
    "Nonsalt Region SC Storage (Bcf)": [
        'Dallas TX', 'San Antonio TX' # Example cities, adjust as needed
    ],
}

# Aggregate all cities from the explicitly defined regions for "Lower 48 States Storage (Bcf)"
all_explicitly_defined_weather_cities = set()
for region, cities in WEATHER_REGION_CITY_MAP.items():
    if region != "Mountain Region Storage (Bcf)": # Exclude Mountain if it's not well-defined
        all_explicitly_defined_weather_cities.update(cities)
WEATHER_REGION_CITY_MAP["Lower 48 States Storage (Bcf)"] = sorted(list(all_explicitly_defined_weather_cities))

# Handle "Mountain Region Storage (Bcf)" - if not explicitly defined above, it will default to empty.
# If you have specific cities for Mountain, add them to WEATHER_REGION_CITY_MAP directly.
if "Mountain Region Storage (Bcf)" not in WEATHER_REGION_CITY_MAP:
    WEATHER_REGION_CITY_MAP["Mountain Region Storage (Bcf)"] = ['Denver CO', 'Salt Lake City UT'] # Example cities, adjust as needed


# --- Data Loading and Cleaning (Original Dashboard) ---
def load_clean_df(file_key, fname, data_path):
    fpath = data_path / fname
    if not fpath.exists():
        print(f"‚ùå Error: Required file '{fname}' not found at {fpath}. Skipping this file.")
        return None
    df = pd.read_csv(fpath)

    if file_key in ["eia_totals", "eia_changes"]:
        df.columns = df.columns.str.lower().str.replace(" (bcf)", "", regex=False).str.replace(" ", "_").str.replace(":", "").str.strip()
        if "period" in df.columns:
            df["period"] = pd.to_datetime(df["period"], errors="coerce")
    elif file_key == "weather":
        df.columns = df.columns.str.strip()
        if 'Date' in df.columns:
            df = df.rename(columns={'Date': 'date'})
            df['date'] = pd.to_datetime(df['date'], errors='coerce')
        if 'City Title' in df.columns:
            # Apply standardization for weather cities
            df = df.rename(columns={'City Title': 'city_title'})
            df['city_title'] = df['city_title'].apply(standardize_city_name)
            # --- DIAGNOSTIC PRINT ADDED HERE ---
            unique_cities = df['city_title'].dropna().unique().tolist()
            print(f"\n--- Diagnostic: Unique cities parsed from WEATHER.csv: {len(unique_cities)} ---")
            print(f"Cities: {unique_cities}")
            print("---------------------------------------------------\n")
            # --- END DIAGNOSTIC PRINT ---
        if 'Avg Temp' in df.columns:
            df = df.rename(columns={'Avg Temp': 'avg_temp'})
        if 'avg_temp' in df.columns:
            df['avg_temp'] = pd.to_numeric(df['avg_temp'], errors='coerce')
    elif file_key == "prices":
        df.columns = df.columns.str.strip()
        if 'Date' in df.columns:
            df = df.rename(columns={'Date': 'date'})
            df['date'] = pd.to_datetime(df['date'], errors='coerce')

        henry_col_found = False
        potential_henry_cols = [col for col in df.columns if 'Henry Hub' in col or 'Henry' == col]
        if 'Henry' in potential_henry_cols:
            df = df.rename(columns={'Henry': 'henry'})
            henry_col_found = True
        elif potential_henry_cols:
            df = df.rename(columns={potential_henry_cols[0]: 'henry'})
            henry_col_found = True

        if henry_col_found:
            df['henry'] = pd.to_numeric(df['henry'], errors='coerce')
    elif file_key in ["fundy", "forecast"]:
        df.columns = df.columns.str.strip()
        if 'Date' in df.columns:
            df['Date'] = pd.to_datetime(df['Date'], errors="coerce")
    elif file_key == "criterion_storage_change":
        df.columns = df.columns.str.strip()
        if 'eff_gas_day' in df.columns:
            df['eff_gas_day'] = pd.to_datetime(df['eff_gas_day'], errors="coerce")
        if 'daily_storage_change' in df.columns:
            df['daily_storage_change'] = pd.to_numeric(df['daily_storage_change'], errors="coerce")
    elif file_key == "nuclear_forecast":
        df.columns = df.columns.str.strip()
        if 'Date' in df.columns:
            df = df.rename(columns={'Date': 'date'})
            df['date'] = pd.to_datetime(df['date'], errors="coerce")
        if 'value' in df.columns:
            df = df.rename(columns={'value': 'mw_generated'})
            df['mw_generated'] = pd.to_numeric(df['mw_generated'], errors="coerce")
    return df

raw_data = {key: load_clean_df(key, fname, data_folder) for key, fname in files.items()}
raw_data = {k: v for k, v in raw_data.items() if v is not None} # Filter out missing files


# --- DIAGNOSTIC PRINT FOR EIA_TOTALS COLUMNS (kept as it's a structural check) ---
print("\n--- Diagnostic: Cleaned columns in EIAtotals.csv ---")
if "eia_totals" in raw_data:
    print(raw_data["eia_totals"].columns.tolist())
else:
    print("EIAtotals.csv was not loaded.")
print("---------------------------------------------------\n")

# --- Extract the EIA report date for weather alignment ---
# This is derived from the latest EIA storage data for the default region
default_eia_report_date_str_temp = None
if "eia_totals" in raw_data and "period" in raw_data["eia_totals"].columns:
    df_eia_period = raw_data["eia_totals"].dropna(subset=["period"])
    if not df_eia_period.empty:
        default_eia_report_date_str_temp = df_eia_period["period"].max().strftime("%Y-%m-%d")

eia_report_date = None
if default_eia_report_date_str_temp and default_eia_report_date_str_temp != "N/A":
    try:
        eia_report_date = datetime.strptime(default_eia_report_date_str_temp, "%Y-%m-%d").date()
    except ValueError:
        print(f"‚ö†Ô∏è Warning: Could not parse EIA report date '{default_eia_report_date_str_temp}' for weather alignment.")


# --- Region Data Processing ---
def process_region_data(display_name, internal_column_name, raw_data, eia_report_date):
    try:
        price_col_name = 'henry' if 'prices' in raw_data and 'henry' in raw_data["prices"].columns else None
            
        prices_weekly = pd.DataFrame()
        if price_col_name and 'prices' in raw_data and not raw_data["prices"].empty:
            prices_weekly = raw_data["prices"].set_index("date").resample("W-FRI")[price_col_name].mean().ffill().reset_index().rename(columns={price_col_name: "weekly_avg_price", "date": "period"})
            prices_weekly.dropna(subset=["weekly_avg_price"], inplace=True)

        merged = pd.DataFrame() # Initialize empty DataFrame
        if "eia_totals" in raw_data and "eia_changes" in raw_data:
            merged = pd.merge(raw_data["eia_totals"], raw_data["eia_changes"], on="period", how="outer")
            if not prices_weekly.empty: merged = merged.merge(prices_weekly, on="period", how="outer")
            merged = merged.sort_values("period")
        else:
            print(f"‚ö†Ô∏è Warning: 'eia_totals' or 'eia_changes' data not found. Skipping region data processing for {display_name}.")
            return None # Cannot proceed without core EIA data

        # --- Check if the internal_column_name exists in the merged DataFrame ---
        if internal_column_name not in merged.columns:
            print(f"‚ùå Error processing region {display_name}: Required storage column '{internal_column_name}' not found in merged data.")
            return None

        df_for_latest = merged.dropna(subset=[internal_column_name])
        if "weekly_avg_price" in df_for_latest.columns:
            df_for_latest = df_for_latest.dropna(subset=["weekly_avg_price"])

        if df_for_latest.empty:
            return None

        latest_valid_row_series = df_for_latest.iloc[-1]

        latest_date = latest_valid_row_series["period"].date()
        latest_price = round(latest_valid_row_series["weekly_avg_price"], 2) \
                                             if pd.notna(latest_valid_row_series.get("weekly_avg_price")) else "N/A"
            
        # --- Storage Position Calculation for Report Tab ---
        current_storage = "N/A"
        five_year_avg = "N/A"
        storage_position_bcf = "N/A"
        storage_position_label = "N/A"

        latest_bcf_value = latest_valid_row_series.get(internal_column_name)
            
        if pd.notna(latest_bcf_value):
            current_storage = round(latest_bcf_value, 1)

            current_week = latest_valid_row_series["period"].isocalendar().week
            
            historical_data_for_week = merged[
                (merged["period"].dt.isocalendar().week == current_week) &
                (merged["period"].dt.year < datetime.now().year)
            ]
            
            min_years_for_avg = 5
            num_historical_years = historical_data_for_week["period"].dt.year.nunique()

            if num_historical_years >= min_years_for_avg:
                mean_bcf_for_week = historical_data_for_week[internal_column_name].mean()
                
                if pd.notna(mean_bcf_for_week):
                    five_year_avg = round(mean_bcf_for_week, 1)
                    
                    storage_position_bcf_val = current_storage - five_year_avg
                    storage_position_bcf = round(storage_position_bcf_val, 1)

                    if storage_position_bcf_val > 0:
                        storage_position_label = f"üü¢ Surplus: +{storage_position_bcf:,.1f} Bcf (Bearish)"
                    elif storage_position_bcf_val < 0:
                        storage_position_label = f"üî¥ Deficit: {storage_position_bcf:,.1f} Bcf (Bullish)"
                    else:
                        storage_position_label = f"‚ö™ In Line: {storage_position_bcf:,.1f} Bcf"
                else:
                    storage_position_label = f"Insufficient historical data (< {min_years_for_avg} years) for 5-Year Avg"

        # --- Weather Data Calculation for Report Tab (MODIFIED) ---
        region_avg_temp = "N/A"
        region_total_cdd = "N/A"
        region_total_hdd = "N/A"
            
        # Get cities for the current storage region from the new map
        cities_for_weather = WEATHER_REGION_CITY_MAP.get(display_name, [])

        weather_df_copy = raw_data.get("weather")

        if cities_for_weather and weather_df_copy is not None and not weather_df_copy.empty:
            required_weather_cols = ['date', 'city_title', 'avg_temp']
            if all(col in weather_df_copy.columns for col in required_weather_cols):
                if eia_report_date:
                    # Filter weather data up to and including the EIA report date
                    weather_data_up_to_eia_date = weather_df_copy[weather_df_copy["date"].dt.date <= eia_report_date].copy()

                    if not weather_data_up_to_eia_date.empty:
                        # Find the actual latest date available in the weather data that is <= EIA report date
                        latest_relevant_weather_date = weather_data_up_to_eia_date["date"].max()
                            
                        # Define the 7-day period ending on this latest relevant weather date
                        one_week_ago = latest_relevant_weather_date - timedelta(days=6)
                        
                        # Filter for the relevant cities and date range
                        recent_week_df = weather_data_up_to_eia_date[
                            (weather_data_up_to_eia_date["date"] >= one_week_ago) &
                            (weather_data_up_to_eia_date["date"] <= latest_relevant_weather_date) &
                            (weather_data_up_to_eia_date["city_title"].isin(cities_for_weather))
                        ].copy()

                        recent_week_df.dropna(subset=['avg_temp'], inplace=True)

                        if not recent_week_df.empty:
                            # Calculate daily average temperature for the entire region
                            daily_region_avg_temp_df = recent_week_df.groupby('date')['avg_temp'].mean().reset_index()
                            
                            if not daily_region_avg_temp_df.empty:
                                # Calculate the overall 7-day average temperature for the region
                                region_avg_temp = round(daily_region_avg_temp_df['avg_temp'].mean(), 1)

                                # Calculate daily CDD and HDD using the region's daily average temp
                                daily_region_avg_temp_df['cdd_daily'] = (daily_region_avg_temp_df['avg_temp'] - BASE_TEMP_CDD_HDD).apply(lambda x: max(0, x))
                                daily_region_avg_temp_df['hdd_daily'] = (BASE_TEMP_CDD_HDD - daily_region_avg_temp_df['avg_temp']).apply(lambda x: max(0, x))

                                # Sum these daily CDD and HDD for the 7-day period
                                region_total_cdd = round(daily_region_avg_temp_df['cdd_daily'].sum(), 1)
                                region_total_hdd = round(daily_region_avg_temp_df['hdd_daily'].sum(), 1)
                                
                            else:
                                print(f"‚ö†Ô∏è Warning: No daily regional average temperatures could be calculated for '{display_name}' in the last 7 days.")
                        else:
                            print(f"‚ö†Ô∏è Warning: No recent weather data found for selected cities in '{display_name}' for the period ending {latest_relevant_weather_date.strftime('%Y-%m-%d')}. Cities: {cities_for_weather}")
                    else:
                        print(f"‚ö†Ô∏è Warning: No weather data found up to EIA report date {eia_report_date.strftime('%Y-%m-%d')} for region {display_name}.")
                else:
                    print(f"‚ö†Ô∏è Warning: EIA report date is not available or valid for region {display_name}. Cannot calculate weather metrics.")
            else:
                print(f"‚ö†Ô∏è Warning: Missing required columns in 'WEATHER.csv' for region {display_name}. Expected: {required_weather_cols}. Actual: {weather_df_copy.columns.tolist()}")
        else:
            print(f"‚ö†Ô∏è Warning: No weather cities defined for region '{display_name}' or 'WEATHER.csv' data not found/empty. Skipping regional weather calculations.")

        # Graph Data & Momentum calculations
        graph_cols = ["period", internal_column_name]
        if "weekly_avg_price" in merged.columns: graph_cols.append("weekly_avg_price")

        graph_df = merged[graph_cols].dropna(subset=["period", internal_column_name]).rename(columns={"period": "Date", internal_column_name: "Bcf"})
        graph_df["Week"], graph_df["Year"] = graph_df["Date"].dt.isocalendar().week.astype(int), graph_df["Date"].dt.year
        graph_df = graph_df[graph_df["Year"] >= 2015]

        chart_map = {i: {"Week": i} for i in range(1, 54)}
        for week, row in graph_df[graph_df["Year"] < datetime.now().year].groupby("Week")["Bcf"].agg(["min", "max", "mean"]).iterrows():
            if week in chart_map: chart_map[int(week)].update({"min": float(row["min"]), "max": float(row["max"]), "mean": float(row["mean"])})

        current_year_for_chart = datetime.now().year

        for year in graph_df["Year"].unique():
            for _, row in graph_df[graph_df["Year"] == year].iterrows():
                if row["Week"] in chart_map:
                    chart_map[row["Week"]].setdefault(f"year_{year}", float(row["Bcf"]))
                    if pd.notna(row.get("weekly_avg_price")):
                        chart_map[row["Week"]].setdefault("price", float(row["weekly_avg_price"]))
                    
                    if year == current_year_for_chart:
                        chart_map[row["Week"]]["Bcf"] = float(row["Bcf"])
                        if pd.notna(row.get("weekly_avg_price")):
                            chart_map[row["Week"]]["price"] = float(row["weekly_avg_price"])


        graph_data_list = sorted([chart_map.get(i, {"Week": i}) for i in range(1, 54)], key=lambda x: x["Week"])

        # --- LOGARITHMIC REGRESSION CALCULATION ---
        log_fit_data = []
            
        fit_df = merged.dropna(subset=[internal_column_name, 'weekly_avg_price']).copy()
        fit_df = fit_df[fit_df[internal_column_name] > 0]

        if not fit_df.empty and len(fit_df) >= 2:
            x_fit = fit_df[internal_column_name].astype(float)
            y_fit = fit_df['weekly_avg_price'].astype(float)

            try:
                coefficients = np.polyfit(np.log(x_fit), y_fit, 1)
                a = coefficients[0]
                b = coefficients[1]

                x_min_fit = x_fit.min()
                x_max_fit = x_fit.max()
                
                x_values_for_line = np.linspace(x_min_fit, x_max_fit, 100)
                
                y_values_for_line = a * np.log(x_values_for_line) + b

                for i in range(len(x_values_for_line)):
                    log_fit_data.append({"x": round(x_values_for_line[i], 2), "y": round(y_values_for_line[i], 2)})
            except Exception as e:
                log_fit_data = []

        return {
            "report": {
                "latest_date": str(latest_date),
                "latest_price": latest_price,
                "current_storage": current_storage,
                "five_year_avg": five_year_avg,
                "storage_position_bcf": storage_position_bcf,
                "storage_position_label": storage_position_label,
                "avg_temp": region_avg_temp, # NEW: Regional average temperature
                "avg_cdd": region_total_cdd,    # NEW: Regional total CDD
                "avg_hdd": region_total_hdd      # NEW: Regional total HDD
            },
            "graph": graph_data_list,
            "log_fit": log_fit_data
        }
    except Exception as e:
        print(f"‚ùå Error processing region {display_name}: {e}")
        return None

# --- Precompute Data (Original Dashboard) ---
# Pass eia_report_date to process_region_data
region_outputs = {d_name: process_region_data(d_name, i_col_name, raw_data, eia_report_date) for d_name, i_col_name in region_map.items()}
region_outputs = {k: v for k, v in region_outputs.items() if v is not None} # Filter out failed regions


# --- Fundy Data Processing (for Balance Trends tab) ---
fundy_df = raw_data.get("fundy")
forecast_df_orig = raw_data.get("forecast") # Renamed to avoid clash with basis_forecast_df

fundy_chart_data = {"labels": [], "values": []}
forecast_chart_data = {"labels": [], "values": []}

if fundy_df is not None and not fundy_df.empty and "item" in fundy_df.columns and "Date" in fundy_df.columns:
    fundy_df_filtered = fundy_df[fundy_df["item"] == "CONUS - Balance"].sort_values("Date")
    fundy_chart_data = {
        "labels": fundy_df_filtered["Date"].dt.strftime("%Y-%m-%d").tolist(),
        "values": fundy_df_filtered["value"].round(2).tolist(),
    }
else:
    print("‚ö†Ô∏è Warning: 'Fundy.csv' data not found, empty, or missing required columns. Skipping historical balance data.")

if forecast_df_orig is not None and not forecast_df_orig.empty and "item" in forecast_df_orig.columns and "Date" in forecast_df_orig.columns:
    forecast_df_filtered = forecast_df_orig[forecast_df_orig["item"] == "CONUS - Balance"].sort_values("Date")
    forecast_chart_data = {
        "labels": forecast_df_filtered["Date"].dt.strftime("%Y-%m-%d").tolist(),
        "values": forecast_df_filtered["value"].round(2).tolist(),
    }
else:
    print("‚ö†Ô∏è Warning: 'FundyForecast.csv' data not found, empty, or missing required columns. Skipping forecast balance data.")


# --- Daily Storage Change Data Processing ---
criterion_df = raw_data.get("criterion_storage_change")
daily_change_chart_data = {}

if criterion_df is not None and not criterion_df.empty:
    if 'storage_name' in criterion_df.columns and 'eff_gas_day' in criterion_df.columns and 'daily_storage_change' in criterion_df.columns:
        for storage_name, group_df in criterion_df.groupby('storage_name'):
            group_df = group_df.sort_values('eff_gas_day')
            daily_change_chart_data[storage_name] = {
                "dates": group_df["eff_gas_day"].dt.strftime("%Y-%m-%d").tolist(),
                "values": group_df["daily_storage_change"].round(2).tolist()
            }
    else:
        print(f"‚ö†Ô∏è Warning: Missing required columns in 'CriterionStorageChange.csv'. Expected: ['storage_name', 'eff_gas_day', 'daily_storage_change']. Actual: {criterion_df.columns.tolist()}")
else:
    print("‚ö†Ô∏è Warning: 'CriterionStorageChange.csv' data not found or is empty. Daily changes chart will not be available.")

# --- Nuclear Generation Data Processing ---
nuclear_df = raw_data.get("nuclear_forecast")
nuclear_generation_chart_data = {"labels": [], "mw_values": [], "price_values": []}

if nuclear_df is not None and not nuclear_df.empty:
    required_nuclear_cols = ['date', 'mw_generated']
    if all(col in nuclear_df.columns for col in required_nuclear_cols):
        daily_nuclear_mw = nuclear_df.groupby('date')['mw_generated'].sum().reset_index()
        daily_nuclear_mw.rename(columns={'mw_generated': 'total_mw_generated'}, inplace=True)
            
        prices_df_for_nuclear = raw_data.get("prices")
        if prices_df_for_nuclear is not None and not prices_df_for_nuclear.empty and 'date' in prices_df_for_nuclear.columns and 'henry' in prices_df_for_nuclear.columns:
            prices_daily = prices_df_for_nuclear.set_index("date")['henry'].resample("D").mean().ffill().reset_index()
            
            merged_nuclear_price = pd.merge(daily_nuclear_mw, prices_daily, on='date', how='left')
            merged_nuclear_price.dropna(subset=['total_mw_generated'], inplace=True)
            
            nuclear_generation_chart_data = {
                "labels": merged_nuclear_price["date"].dt.strftime("%Y-%m-%d").tolist(),
                "mw_values": merged_nuclear_price["total_mw_generated"].round(2).tolist(),
                "price_values": merged_nuclear_price["henry"].round(2).tolist()
            }
        else:
            print("‚ö†Ô∏è Warning: Henry Hub price data not available or missing required columns for merging with nuclear generation. Nuclear chart will display only MW values.")
            nuclear_generation_chart_data = {
                "labels": daily_nuclear_mw["date"].dt.strftime("%Y-%m-%d").tolist(),
                "mw_values": daily_nuclear_mw["total_mw_generated"].round(2).tolist(),
                "price_values": [None] * len(daily_nuclear_mw)
            }
    else:
        print(f"‚ö†Ô∏è Warning: Missing required columns in 'NuclearForecast.csv'. Expected: {required_nuclear_cols}. Actual: {nuclear_df.columns.tolist()}")
else:
    print("‚ö†Ô∏è Warning: 'NuclearForecast.csv' data not found or is empty. Nuclear generation chart will not be available.")


# --- BASIS ANALYSIS DATA LOADING AND PREPARATION (NEW) ---
def load_basis_data(prices_path, weather_hist_path, weather_forecast_path):
    print("\n--- Starting Basis Data Loading ---")
    prices_df_basis = None
    weather_df_basis = None
    forecast_df_basis = None

    try:
        prices_df_basis = pd.read_csv(prices_path)
        prices_df_basis['Date'] = pd.to_datetime(prices_df_basis['Date'], errors='coerce')
        print(f"Loaded {prices_path.name} for Basis Analysis successfully.")
    except Exception as e:
        print(f"ERROR: Failed to load PRICES.csv for Basis Analysis from {prices_path}: {e}")

    try:
        weather_df_basis = pd.read_csv(weather_hist_path)
        weather_df_basis['Date'] = pd.to_datetime(weather_df_basis['Date'], errors='coerce')
        if 'City Title' in weather_df_basis.columns:
            weather_df_basis['City Title'] = weather_df_basis['City Title'].apply(standardize_city_name)
            print(f"Loaded {weather_hist_path.name} for Basis Analysis successfully.")
        else:
            print(f"WARNING: '{weather_hist_path.name}' is missing 'City Title' column. Basis analysis might be affected.")
            weather_df_basis = pd.DataFrame()
    except Exception as e:
        print(f"ERROR: Failed to load WEATHER.csv for Basis Analysis from {weather_hist_path}: {e}")

    try:
        forecast_df_basis = pd.read_csv(weather_forecast_path)
        forecast_df_basis['Date'] = pd.to_datetime(forecast_df_basis['Date'], errors='coerce')
        forecast_df_basis = forecast_df_basis.dropna(subset=['Date']).sort_values(by='Date')
        if 'City Title' in forecast_df_basis.columns:
            forecast_df_basis['City Title'] = forecast_df_basis['City Title'].apply(standardize_city_name)
            
            # Filter forecast data for dates starting from tomorrow's date for a consistent 7-day future view
            forecast_start_date = datetime.now().date() + timedelta(days=1)
            forecast_df_basis = forecast_df_basis[forecast_df_basis['Date'].dt.date >= forecast_start_date].copy()
            print(f"Loaded and filtered {weather_forecast_path.name} for Basis Analysis.")
        else:
            print(f"WARNING: '{weather_forecast_path.name}' is missing 'City Title' column. Basis forecast might be affected.")
            forecast_df_basis = pd.DataFrame()
    except FileNotFoundError:
        print(f"WARNING: WEATHERforecast.csv not found for Basis Analysis at {weather_forecast_path}. Forecast table will be empty.")
    except Exception as e:
        print(f"ERROR: Failed to load WEATHERforecast.csv for Basis Analysis: {e}. Forecast table will be empty.")

    print("--- Basis Data Loading Complete ---")
    return prices_df_basis, weather_df_basis, forecast_df_basis, COMPONENT_TO_CITY_MAP_HARDCODED

def prepare_basis_dashboard_data(prices_df, weather_df, forecast_df, component_to_city, henry_hub_name):
    """Prepares all data for the interactive Plotly dashboard and forecast table."""
    
    print("\n--- Starting Basis Data Preparation for Dashboard ---")

    valid_components = []
    if prices_df is not None and henry_hub_name in prices_df.columns and component_to_city:
        for comp in prices_df.columns:
            if comp != 'Date' and comp != henry_hub_name and comp in component_to_city:
                if pd.to_numeric(prices_df[comp], errors='coerce').notna().sum() > 0:
                    valid_components.append(comp)
    else:
        print("WARNING: Insufficient primary data (prices_df, Henry Hub, or city map) to identify valid components for Basis Analysis.")
        return {}

    basis_data_js = {}
    colors = plotly.colors.qualitative.Plotly
    current_year = datetime.now().year
    start_year_for_analysis = current_year - 3 # Analyze last 4 years including current

    for comp in valid_components:
        city = component_to_city.get(comp)
        if not city:
            print(f"WARNING: Skipping component '{comp}': No city mapping found in hardcoded map for Basis Analysis.")
            basis_data_js[comp] = {
                'city': 'N/A',
                'overall_x': [], 'overall_y': [], 'overall_fit_x': [], 'overall_fit_y': [],
                'overall_formula': "N/A (No city mapping)",
                'per_year_data': [],
                'forecast_table_data': []
            }
            continue

        city_weather = weather_df[weather_df['City Title'].astype(str).str.strip() == city].copy()

        hist_merged_all = pd.merge(
            prices_df[['Date', comp, henry_hub_name]],
            city_weather[['Date', 'Avg Temp']],
            on='Date', how='inner'
        ).dropna(subset=[comp, henry_hub_name, 'Avg Temp'])

        hist_merged_all = hist_merged_all[hist_merged_all['Date'].dt.year >= start_year_for_analysis].copy()

        if hist_merged_all.empty or hist_merged_all['Avg Temp'].isnull().all() or hist_merged_all[comp].isnull().all():
            print(f"WARNING: Skipping {comp} for Basis Analysis: Not enough historical data for plotting in the last 4 years or critical columns are empty.")
            basis_data_js[comp] = {
                'city': city,
                'overall_x': [], 'overall_y': [], 'overall_fit_x': [], 'overall_fit_y': [],
                'overall_formula': "N/A (Insufficient historical data)",
                'per_year_data': [],
                'forecast_table_data': []
            }
            continue

        hist_merged_all[comp] = pd.to_numeric(hist_merged_all[comp], errors='coerce')
        hist_merged_all[henry_hub_name] = pd.to_numeric(hist_merged_all[henry_hub_name], errors='coerce')
        hist_merged_all['Basis'] = hist_merged_all[comp] - hist_merged_all[henry_hub_name]

        overall_data_for_fit = hist_merged_all.dropna(subset=['Avg Temp', 'Basis']).copy()

        overall_formula_str = "N/A (Insufficient data for overall quadratic fit)"
        overall_fit_x_smooth = np.array([])
        overall_fit_y_smooth = np.array([])
        overall_coeffs = None

        if len(overall_data_for_fit) >= 3:
            try:
                overall_coeffs = np.polyfit(overall_data_for_fit['Avg Temp'], overall_data_for_fit['Basis'], 2)
                overall_formula_str = (
                    f"Basis = {overall_coeffs[0]:.4f} * Temp¬≤ + "
                    f"{overall_coeffs[1]:.4f} * Temp + {overall_coeffs[2]:.4f}"
                )
                
                overall_temp_min = overall_data_for_fit['Avg Temp'].min()
                overall_temp_max = overall_data_for_fit['Avg Temp'].max()
                overall_fit_x_smooth = np.linspace(overall_temp_min, overall_temp_max, 100)
                overall_poly_func = np.poly1d(overall_coeffs)
                overall_fit_y_smooth = overall_poly_func(overall_fit_x_smooth)

            except Exception as e:
                print(f"WARNING: Error calculating overall quadratic fit for {comp}: {e}. Formula will be N/A.")
                pass

        per_year_data = []
        unique_years_in_range = [int(y) for y in sorted(hist_merged_all['Date'].dt.year.unique())]
            
        for i, year in enumerate(unique_years_in_range):
            year_data = hist_merged_all[hist_merged_all['Date'].dt.year == year].copy()
            
            if year_data.empty:
                continue

            x_year = year_data['Avg Temp'].values
            y_year = year_data['Basis'].values
            
            year_data_for_fit = year_data.dropna(subset=['Avg Temp', 'Basis']).copy()

            year_formula_str = "N/A"
            year_fit_x_smooth = np.array([])
            year_fit_y_smooth = np.array([])

            if len(year_data_for_fit) >= 3:
                try:
                    year_coeffs = np.polyfit(year_data_for_fit['Avg Temp'], year_data_for_fit['Basis'], 2)
                    year_formula_str = (
                        f"Basis = {year_coeffs[0]:.4f} * Temp¬≤ + "
                        f"{year_coeffs[1]:.4f} * Temp + {year_coeffs[2]:.4f} (Year {year})"
                    )
                    
                    year_temp_min = year_data_for_fit['Avg Temp'].min()
                    year_temp_max = year_data_for_fit['Avg Temp'].max()
                    year_fit_x_smooth = np.linspace(year_temp_min, year_temp_max, 50)
                    year_poly_func = np.poly1d(year_coeffs)
                    year_fit_y_smooth = year_poly_func(year_fit_x_smooth)
                except Exception as e:
                    print(f"WARNING: Error calculating quadratic fit for {comp} year {year}: {e}. Formula will be N/A.")
                    pass

            valid_indices_year = ~np.isnan(y_year) & ~np.isnan(x_year)
            clean_x_year = x_year[valid_indices_year].tolist()
            clean_y_year = y_year[valid_indices_year].tolist()
            
            valid_fit_indices_year_smooth = ~np.isnan(year_fit_y_smooth)
            clean_x_year_for_fit = year_fit_x_smooth[valid_fit_indices_year_smooth].tolist()
            clean_y_year_for_fit_line = year_fit_y_smooth[valid_fit_indices_year_smooth].tolist()


            per_year_data.append({
                'year': year,
                'x': clean_x_year,
                'y': clean_y_year,
                'fit_x': clean_x_year_for_fit,
                'fit_y': clean_y_year_for_fit_line,
                'formula': year_formula_str,
                'color': colors[i % len(colors)]
            })

        forecast_table_data = []
        if overall_coeffs is not None and forecast_df is not None and not forecast_df.empty and 'City Title' in forecast_df.columns:
            city_forecast = forecast_df[forecast_df['City Title'].astype(str).str.strip() == city].copy()
            city_forecast = city_forecast.sort_values(by='Date').head(7).copy() # Take first 7 days for this city
            
            if not city_forecast.empty:
                overall_poly_func_for_forecast = np.poly1d(overall_coeffs)
                city_forecast['Predicted Basis'] = city_forecast['Avg Temp'].apply(
                    lambda temp: overall_poly_func_for_forecast(temp) if pd.notna(temp) else np.nan
                )
                city_forecast = city_forecast.dropna(subset=['Predicted Basis']).copy()
                
                for _, row in city_forecast.iterrows():
                    forecast_table_data.append({
                        'Date': row['Date'].strftime('%Y-%m-%d'),
                        'Avg Temp': round(row['Avg Temp'], 1),
                        'Predicted Basis': round(row['Predicted Basis'], 3)
                    })
            else:
                print(f"WARNING: No 7-day forecast data found for city '{city}' in WEATHERforecast.csv starting from the specified forecast start date.")


        overall_valid_fit_indices_smooth = ~np.isnan(overall_fit_y_smooth)
        clean_overall_x_for_fit = overall_fit_x_smooth[overall_valid_fit_indices_smooth].tolist()
        clean_overall_y_for_fit = overall_fit_y_smooth[overall_valid_fit_indices_smooth].tolist()

        clean_hist_x_all = hist_merged_all['Avg Temp'].values[~np.isnan(hist_merged_all['Basis'].values) & ~np.isnan(hist_merged_all['Avg Temp'].values)].tolist()
        clean_hist_y_all = hist_merged_all['Basis'].values[~np.isnan(hist_merged_all['Basis'].values) & ~np.isnan(hist_merged_all['Avg Temp'].values)].tolist()

        basis_data_js[comp] = {
            'city': city,
            'overall_x': clean_hist_x_all,
            'overall_y': clean_hist_y_all,
            'overall_fit_x': clean_overall_x_for_fit,
            'overall_fit_y': clean_overall_y_for_fit,
            'overall_formula': overall_formula_str,
            'per_year_data': per_year_data,
            'forecast_table_data': forecast_table_data
        }
    print("--- Basis Data Preparation Complete ---")
    return basis_data_js


# --- Main Execution ---
if __name__ == "__main__":
    # --- Load and Process Original Dashboard Data ---
    # raw_data is already loaded at the top using load_clean_df
    # region_outputs is already processed
    # avg_temp, avg_cdd, avg_hdd are already calculated
    # fundy_chart_data, forecast_chart_data are already processed
    # daily_change_chart_data is already processed
    # nuclear_generation_chart_data is already processed

    # --- Load and Process Basis Analysis Data ---
    prices_df_basis, weather_df_basis, forecast_df_basis, component_to_city_map_basis = load_basis_data(
        PRICES_FILE_BASIS, WEATHER_HISTORICAL_FILE_BASIS, WEATHER_FORECAST_FILE_BASIS
    )

    basis_data_for_js = {}
    if prices_df_basis is not None and weather_df_basis is not None and forecast_df_basis is not None:
        basis_data_for_js = prepare_basis_dashboard_data(
            prices_df_basis, weather_df_basis, forecast_df_basis, component_to_city_map_basis, HENRY_HUB_NAME
        )
        
    basis_data_json_str = json.dumps(basis_data_for_js, indent=2)

    # --- Extract Report Data for Initial HTML Render ---
    # These values will be updated dynamically by JavaScript based on selected region
    report_latest_date = region_outputs.get(DEFAULT_REGION_DISPLAY_NAME, {}).get("report", {}).get("latest_date", "N/A")
    report_latest_price = region_outputs.get(DEFAULT_REGION_DISPLAY_NAME, {}).get("report", {}).get("latest_price", "N/A")
    report_current_storage = region_outputs.get(DEFAULT_REGION_DISPLAY_NAME, {}).get("report", {}).get("current_storage", "N/A")
    report_five_year_avg = region_outputs.get(DEFAULT_REGION_DISPLAY_NAME, {}).get("report", {}).get("five_year_avg", "N/A")
    report_storage_position_label = region_outputs.get(DEFAULT_REGION_DISPLAY_NAME, {}).get("report", {}).get("storage_position_label", "N/A")
    # Initial regional weather values for the default region - these are now calculated within process_region_data
    report_avg_temp = region_outputs.get(DEFAULT_REGION_DISPLAY_NAME, {}).get("report", {}).get("avg_temp", "N/A")
    report_avg_cdd = region_outputs.get(DEFAULT_REGION_DISPLAY_NAME, {}).get("report", {}).get("avg_cdd", "N/A")
    report_avg_hdd = region_outputs.get(DEFAULT_REGION_DISPLAY_NAME, {}).get("report", {}).get("avg_hdd", "N/A")


    # --- HTML Components ---
    region_options_html = ''.join([f'<option value="{r}"{" selected" if r == DEFAULT_REGION_DISPLAY_NAME else ""}>{r}</option>' for r in region_outputs.keys()])
    storage_name_options_html = ''.join([f'<option value="{name}">{name}</option>' for name in sorted(daily_change_chart_data.keys())])

    # Get valid components for basis analysis dropdown
    valid_basis_components = sorted(list(basis_data_for_js.keys()))
    basis_component_options_html = "".join(f"<option value='{comp}'>{comp}</option>" for comp in valid_basis_components)


    region_outputs_json = json.dumps(region_outputs, default=str)
    fundy_chart_data_json = json.dumps(fundy_chart_data)
    forecast_chart_data_json = json.dumps(forecast_chart_data)
    daily_change_chart_data_json = json.dumps(daily_change_chart_data)
    nuclear_generation_chart_data_json = json.dumps(nuclear_generation_chart_data)


    # --- HTML Template (Consolidated and all {{ }} for literals) ---
    html_template_raw = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Natural Gas Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@latest/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src='https://cdn.plot.ly/plotly-latest.min.js'></script> <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {{font-family: 'Segoe UI', sans-serif; padding: 20px; background-color: #eef2f3; color: #333; line-height: 1.6;}}
        .container {{max-width: 960px; margin: 30px auto; background-color: #fff; padding: 40px; border-radius: 12px; box-shadow: 0 8px 20px rgba(0,0,0,0.15);}}
        h1 {{color: #2c3e50; text-align: center; margin-bottom: 30px; font-size: 2.5em; border-bottom: 3px solid #3498db; padding-bottom: 15px;}}
        h2 {{color: #34495e; font-size: 1.6em; margin-top: 0; margin-bottom: 25px; border-bottom: 1px solid #dae1e7; padding-bottom: 12px;}}
        .controls {{text-align: center; margin-bottom: 20px;}}
        .tab-buttons {{margin-top: 15px; display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;}}
        .tab-buttons button {{background-color: #3498db; color: white; border: none; padding: 14px 30px; border-radius: 10px; cursor: pointer; transition: background-color 0.3s, transform 0.2s; box-shadow: 0 4px 10px rgba(0,0,0,0.1);}}
        .tab-buttons button:hover {{background-color: #2980b9; transform: translateY(-2px);}}
        .tab-buttons button.active {{background-color: #2ecc71; box-shadow: 0 3px 8px rgba(46, 204, 113, 0.4);}}
        .tab {{display: none; background-color: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); margin-top: 25px;}}
        .tab.active {{display: block;}}
        .summary-item {{background-color: #ecf0f1; padding: 12px 15px; border-radius: 6px; margin-bottom: 10px; border-left: 5px solid #3498db; display: flex; align-items: center; font-size: 1.05em;}}
        .summary-item strong {{color: #2c3e50; font-weight: 700; display: inline-block; min-width: 180px; margin-right: 10px;}}
        canvas {{background: #fff; border: 1px solid #e0e0e0; border-radius: 8px; margin-top: 25px; width: 100% !important; height: 400px !important;}}
        .graph-controls {{text-align: center; margin-bottom: 25px;}}
        select {{padding: 12px; border-radius: 8px; border: 1px solid #bbb; font-size: 1.0em; min-width: 300px; margin-bottom: 15px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.08); appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13.6-6.4H19.2c-5%200-9.6%202-13.6%206.4-4%204-6.4%209.6-6.4%2016.2%200%206.5%202.4%2012.2%206.4%2016.2l128%20127.9c4%204%209.6%206.4%2016.2%206.4s12.2-2.4%2016.2-6.4l128-127.9c4-4%206.4-9.6%206.4-16.2-.1-6.6-2.5-12.2-6.5-16.2z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 10px center; background-size: 12px; padding-right: 30px;}}
        .chart-legend-toggles {{text-align: left; margin-top: 20px; padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #fcfcfc; display: flex; flex-wrap: wrap; gap: 15px;}}
        .chart-legend-toggles label {{display: flex; align-items: center; margin-right: 0; font-size: 0.95em; cursor: pointer; color: #555; transition: color 0.2s ease;}}
        .chart-legend-toggles label:hover {{color: #2c3e50;}}
        .chart-legend-toggles input[type="checkbox"] {{margin-right: 8px; transform: scale(1.1); cursor: pointer;}}
        .chart-legend-toggles .color-square {{display: inline-block; width: 14px; height: 14px; margin-right: 8px; border-radius: 4px; vertical-align: middle; border: 1px solid rgba(0,0,0,0.1);}}
        
        /* Styles for Basis Analysis tab */
        #basis-analysis-tab #plot {{ width: 100%; height: 600px; margin-bottom: 20px; border: 1px solid #eee; border-radius: 8px; }}
        #basis-analysis-tab #formula {{ text-align: center; font-size: 1.1em; font-weight: bold; margin-bottom: 30px; padding: 15px; background-color: #eaf6ff; border-radius: 8px; border: 1px solid #cce5ff; }}
        #basis-analysis-tab #forecast_table {{ margin-top: 40px; text-align: center; }}
        #basis-analysis-tab #forecast_table h3 {{ color: #2980b9; margin-bottom: 20px; font-size: 1.6em; }}
        #basis-analysis-tab #forecast_table table {{
            width: 80%; margin: 0 auto; border-collapse: separate; border-spacing: 0;
            border-radius: 8px; overflow: hidden; box-shadow: 0 2px 10px rgba(0,0,0,0.08);
        }}
        #basis-analysis-tab #forecast_table th, #basis-analysis-tab #forecast_table td {{
            border: 1px solid #e0e0e0; padding: 12px 15px; text-align: center;
            font-size: 0.95em;
        }}
        #basis-analysis-tab #forecast_table th {{ background-color: #f0f0f0; color: #555; font-weight: bold; }}
        #basis-analysis-tab #forecast_table tr:nth-child(even) {{ background-color: #f9f9f9; }}
        #basis-analysis-tab #forecast_table tr:hover {{ background-color: #eef; }}


        @media (max-width: 768px) {{
            .container {{margin: 10px; padding: 20px;}} h1 {{font-size: 2em;}} h2 {{font-size: 1.4em;}}
            .tab-buttons {{flex-direction: column; gap: 8px;}} .tab-buttons button {{width: 90%; margin: 0 auto; padding: 10px 20px;}}
            select {{min-width: unset; width: 90%;}} .chart-legend-toggles {{flex-direction: column; gap: 8px; padding: 10px;}}
            .summary-item strong {{min-width: 120px;}}
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Natural Gas Dashboard</h1>
        <div class="controls">
            <div class="tab-buttons">
                <button id="report-tab-button" onclick="showTab('report')">üìÑ Report</button>
                <button id="storage-info-tab-button" onclick="showTab('storage-info')">üìä Storage Information</button>
                <button id="balance-tab-button" onclick="showTab('balance')">‚öôÔ∏è Balance Trends</button>
                <button id="daily-changes-tab-button" onclick="showTab('daily-changes')">üìà Daily Changes</button>
                <button id="nuclear-tab-button" onclick="showTab('nuclear')">‚ö° Nuclear Generation</button>
                <button id="basis-analysis-tab-button" onclick="showTab('basis-analysis')">üå°Ô∏è Basis Analysis</button> </div>
        </div>
        <div id="report" class="tab">
            <h2>Market Report</h2>
            <div class="graph-controls" style="margin-top: 20px;">
                <label for="report-region-select">Select Region for Report:</label>
                <select id="report-region-select">
                    {region_options_html}
                </select>
            </div>
            <div id="report-content" class="summary">
            </div>
        </div>
        <div id="storage-info" class="tab">
            <div class="graph-controls" style="margin-top: 20px;">
                <label for="region-select">Select Region:</label>
                <select id="region-select">
                    <option value="">-- Choose Region --</option>
                    {region_options_html}
                </select>
            </div>
            <div class="graph-section">
                <h2>EIA Storage Graph</h2>
                <canvas id="chart"></canvas>
                <div id="chart-legend-toggles" class="chart-legend-toggles" style="display: none;">
                </div>
            </div>
            <div class="graph-section" style="margin-top: 40px;">
                <h2>Storage vs Henry Hub Price</h2>
                <canvas id="scatter-chart"></canvas>
            </div>
        </div>
        <div id="balance" class="tab">
            <h2>CONUS Balance: Historical vs Forecast</h2>
            <canvas id="balance-chart"></canvas>
        </div>
        <div id="daily-changes" class="tab">
            <h2>Daily Storage Changes by Storage Name</h2>
            <div class="graph-controls" style="margin-top: 20px;">
                <label for="daily-change-select">Select Storage Name:</label>
                <select id="daily-change-select">
                    <option value="">-- Choose Storage Name --</option>
                    {storage_name_options_html}
                </select>
            </div>
            <canvas id="daily-change-chart"></canvas>
        </div>
        <div id="nuclear" class="tab">
            <h2>U.S. Nuclear Generation Trend</h2>
            <canvas id="nuclear-chart"></canvas>
        </div>
        
        <div id="basis-analysis" class="tab">
            <h2>Market Basis and Temperature Analysis</h2>
            <div class="graph-controls" style="margin-top: 20px;">
                <label for="componentDropdown">Select Market Component:</label>
                <select id='componentDropdown' onchange='updateBasisGraph()'>
                    {"".join(f"<option value='{comp}'>{comp}</option>" for comp in valid_basis_components)}
                </select>
            </div>
            <div id='plot'></div>
            <div id='formula'></div>
            <div id='forecast_table'></div>
        </div>
        
    </div>
<script>
    // --- Data for Original Dashboard Tabs ---
    const allRegionData = {region_outputs_json};
    // Removed globalAvgTemp, globalAvgCDD, globalAvgHDD from here as they are now per-region
    const defaultRegion = "{DEFAULT_REGION_DISPLAY_NAME}";

    const fundyChartData = {fundy_chart_data_json};
    const forecastChartData = {forecast_chart_data_json};
    const dailyChangeChartData = {daily_change_chart_data_json};
    const nuclearGenerationChartData = {nuclear_generation_chart_data_json};

    // --- Data for New Basis Analysis Tab ---
    const basisData = {basis_data_json_str};

    let myChart; // EIA Storage Chart.js
    let balanceChart; // Balance Trends Chart.js
    let scatterChart; // Storage vs Price Chart.js
    let dailyChangeChart; // Daily Storage Change Chart.js
    let nuclearChart; // Nuclear Generation Chart.js
    let basisPlotlyChart; // New: Basis Analysis Plotly chart

    function showTab(tabId) {{
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.getElementById(tabId).classList.add('active');
        document.querySelectorAll('.tab-buttons button').forEach(btn => btn.classList.remove('active'));
        document.getElementById(tabId + '-tab-button').classList.add('active');

        // Destroy charts from other tabs if switching away
        if (tabId !== 'balance' && balanceChart) {{ balanceChart.destroy(); balanceChart = null; }}
        if (tabId !== 'daily-changes' && dailyChangeChart) {{ dailyChangeChart.destroy(); dailyChangeChart = null; }}
        if (tabId !== 'nuclear' && nuclearChart) {{ nuclearChart.destroy(); nuclearChart = null; }}
        if (tabId !== 'storage-info') {{
            if (myChart) {{ myChart.destroy(); myChart = null; }}
            if (scatterChart) {{ scatterChart.destroy(); scatterChart = null; }}
            document.getElementById("chart-legend-toggles").innerHTML = "";
            document.getElementById("chart-legend-toggles").style.display = 'none';
        }}
        // NEW: Destroy Plotly chart if switching away from Basis Analysis tab
        if (tabId !== 'basis-analysis' && basisPlotlyChart) {{
            Plotly.purge('plot'); // Use Plotly.purge for Plotly charts
            basisPlotlyChart = null;
        }}


        // Handle specific tab initializations
        if (tabId === 'storage-info') {{
            const storageRegionSelect = document.getElementById("region-select");
            const currentSelectedRegion = storageRegionSelect.value;
            if (currentSelectedRegion && currentSelectedRegion !== "") {{
                updateEIAStorageGraph(currentSelectedRegion);
                updateStoragePriceScatter(currentSelectedRegion);
            }} else {{
                if (myChart) {{ myChart.destroy(); myChart = null; }}
                if (scatterChart) {{ scatterChart.destroy(); scatterChart = null; }}
                document.getElementById("chart").getContext("2d").clearRect(0, 0, document.getElementById("chart").width, document.getElementById("chart").height);
                document.getElementById("scatter-chart").getContext("2d").clearRect(0, 0, document.getElementById("scatter-chart").width, document.getElementById("scatter-chart").height);
                document.getElementById("chart-legend-toggles").innerHTML = "<p><em>Select a region from the dropdown above to view its storage graphs.</em></p>";
                document.getElementById("chart-legend-toggles").style.display = 'block';
            }}
        }} else if (tabId === 'report') {{
            const reportRegionSelect = document.getElementById("report-region-select");
            if (!reportRegionSelect.value) {{
                reportRegionSelect.value = defaultRegion;
            }}
            updateReportContent(reportRegionSelect.value);
        }} else if (tabId === 'balance') {{
            updateBalanceChart();
        }} else if (tabId === 'daily-changes') {{
            const dailyChangeSelect = document.getElementById("daily-change-select");
            if (dailyChangeSelect.value) {{
                updateDailyChangeChart(dailyChangeSelect.value);
            }} else {{
                if (dailyChangeChart) {{ dailyChangeChart.destroy(); dailyChangeChart = null; }}
                document.getElementById("daily-change-chart").getContext("2d").clearRect(0, 0, document.getElementById("daily-change-chart").width, document.getElementById("daily-change-chart").height);
            }}
        }} else if (tabId === 'nuclear') {{
            updateNuclearChart();
        }} else if (tabId === 'basis-analysis') {{ // NEW: Basis Analysis tab initialization
            const componentDropdown = document.getElementById('componentDropdown');
            if (componentDropdown.value) {{
                updateBasisGraph(); // Call the Plotly update function
            }} else if (componentDropdown.options.length > 0) {{
                // Set default to first option if no value is set
                componentDropdown.value = componentDropdown.options[0].value;
                updateBasisGraph();
            }} else {{
                document.getElementById('plot').innerHTML = '<p style="text-align:center;">No market components available for Basis Analysis.</p>';
                document.getElementById('formula').innerHTML = '';
                document.getElementById('forecast_table').innerHTML = '';
            }}
        }}
    }}

    function updateReportContent(selectedRegion) {{
        const reportContentDiv = document.getElementById("report-content");
        const report = allRegionData[selectedRegion] ? allRegionData[selectedRegion].report : null;

        if(report) {{
            reportContentDiv.innerHTML = `
                <div class="summary-item"><strong>Date:</strong> ${{report.latest_date}}</div>
                <div class="summary-item"><strong>Latest Price:</strong> ${{report.latest_price}}</div>
                <div class="summary-item"><strong>Avg Temp (${{selectedRegion.split(' ')[0]}} Region, Last 7 Days):</strong> ${{report.avg_temp}}</div>
                <div class="summary-item"><strong>Cooling Degree Days (${{selectedRegion.split(' ')[0]}} Region, 7-day total):</strong> ${{report.avg_cdd}}</div>
                <div class="summary-item"><strong>Heating Degree Days (${{selectedRegion.split(' ')[0]}} Region, 7-day total):</strong> ${{report.avg_hdd}}</div>
                <div class="summary-item"><strong>Current Storage ${{selectedRegion.includes("Lower 48") ? "(L48)" : "(Regional)"}}:</strong> ${{report.current_storage}} Bcf</div>
                <div class="summary-item"><strong>5-Year Avg ${{selectedRegion.includes("Lower 48") ? "(L48)" : "(Regional)"}}:</strong> ${{report.five_year_avg}} Bcf</div>
                <div class="summary-item"><strong>Storage Position ${{selectedRegion.includes("Lower 48") ? "(L48)" : "(Regional)"}}:</strong> ${{report.storage_position_label}}</div>
            `;
        }} else {{
            reportContentDiv.innerHTML = `<p><strong>No market report data available for ${{selectedRegion}}.</strong></p>`;
        }}
    }}

    const getWeekMonthLabels = () => {{
        const labels = [];
        const monthMap = ["Jan", "Jan", "Jan", "Jan", "Feb", "Feb", "Feb", "Feb", "Mar", "Mar", "Mar", "Mar", "Apr", "Apr", "Apr", "Apr", "May", "May", "May", "May", "Jun", "Jun", "Jun", "Jun", "Jun", "Jul", "Jul", "Jul", "Jul", "Aug", "Aug", "Aug", "Aug", "Sep", "Sep", "Sep", "Sep", "Oct", "Oct", "Oct", "Oct", "Nov", "Nov", "Nov", "Nov", "Dec", "Dec", "Dec", "Dec", "Dec", "Dec", "Dec"];
        for (let i = 1; i <= 53; i++) {{ labels.push(`${{i}} (${{monthMap[i - 1] || ''}})`); }}
        return labels;
    }};

    const colors = {{
        shaded_area: 'rgba(200, 200, 200, 0.3)', curr: "#2ecc71", price: "#9b59b6",
        proj_2020: "#8e44ad", proj_2021: "#3498db", proj_2022: "#1abc9c", proj_2023: "#f1c40f", proj_2024: "#e74c3c",
        year_2015: "#FFC300", year_2016: "#FF5733", year_2017: "#C70039", year_2018: "#900C3F", year_2019: "#581845",
        year_2020: "#009688", year_2021: "#4CAF50", year_2022: "#8BC34A", year_2023: "#CDDC39", year_2024: "#FFEB3B",
        scatter_points: '#3498db',
        log_fit_line: '#e74c3c'
    }};

    function updateEIAStorageGraph(region_display_name) {{
        const regionDataKey = region_display_name;
        const chartCanvas = document.getElementById("chart");
        const chartTogglesDiv = document.getElementById("chart-legend-toggles");

        if (!regionDataKey || !(regionDataKey in allRegionData)) {{
            if (myChart) {{ myChart.destroy(); myChart = null; }}
            chartTogglesDiv.innerHTML = "<p><em>Select a valid region for storage graph.</em></p>";
            chartTogglesDiv.style.display = 'block'; return;
        }}

        const graphData = allRegionData[regionDataKey].graph;
        const labels = getWeekMonthLabels();

        const minData = graphData.map(d => d.min !== undefined ? d.min : null);
        const maxData = graphData.map(d => d.max !== undefined ? d.max : null);
        const years = [], projections = [];
        if (graphData.length > 0) {{ Object.keys(graphData[0]).forEach(key => {{ if (key.startsWith("year_")) years.push(key); if (key.startsWith("proj_")) projections.push(key); }}); }}

        const currentFullYear = new Date().getFullYear();
        const currYearKey = `year_${{currentFullYear}}`;
        const currYearData = graphData.map(d => d[currYearKey] !== undefined ? d[currYearKey] : null);
        let lastActualCurrYearWeek = currYearData.length - 1; while (lastActualCurrYearWeek >= 0 && currYearData[lastActualCurrYearWeek] === null) lastActualCurrYearWeek--;
        const trimmedCurrYearData = currYearData.slice(0, lastActualCurrYearWeek + 1);

        const projDatasets = projections.map(projKey => ({{ label: `Projection ${{projKey.replace("proj_", "")}} Scenario`, data: graphData.map(d => d[projKey] ?? null), borderColor: colors[projKey] || "#cccccc", borderDash: [5, 5], fill: false, hidden: (projKey !== 'proj_2022'), tension: 0.1, pointRadius: 2 }}));
        const historicalYearDatasets = years.filter(key => key !== currYearKey).map(yearKey => ({{ label: `Year ${{yearKey.replace("year_", "")}}`, data: graphData.map(d => d[yearKey] ?? null), borderColor: colors[yearKey] || "#cccccc", fill: false, hidden: false, tension: 0.1, pointRadius: 2 }}));
        const priceData = graphData.map(d => d.price ?? null);

        let yAxesConfig = {{ y_storage: {{ type: 'linear', display: true, position: 'left', title: {{ display: true, text: 'Storage (Bcf)', font: {{ size: 14, weight: 'bold' }} }}, ticks: {{ font: {{ size: 12 }} }}, grid: {{ color: '#e0e0e0' }} }} }};
        let priceAxisAdded = false;
        if (priceData.some(val => val !== null)) {{ yAxesConfig['y_price'] = {{ type: 'linear', display: true, position: 'right', title: {{ display: true, text: 'Price ($/MMBtu)', font: {{ size: 14, weight: 'bold' }} }}, grid: {{ drawOnChartArea: false }}, ticks: {{ font: {{ size: 12 }} }} }}; priceAxisAdded = true; }}

        const datasets = [
            {{ label: "Min Data (Internal)", data: minData, borderColor: 'transparent', backgroundColor: 'transparent', pointRadius: 0, pointHoverRadius: 0, fill: false, hidden: true, tension: 0.1, yAxisID: 'y_storage' }},
            {{ label: "Max Data (Internal)", data: maxData, borderColor: 'transparent', backgroundColor: colors.shaded_area, pointRadius: 0, pointHoverRadius: 0, fill: {{ target: '-1', above: colors.shaded_area, below: colors.shaded_area }}, hidden: true, tension: 0.1, yAxisID: 'y_storage' }},
            ...historicalYearDatasets, ...projDatasets,
            currYearKey ? {{ label: `Current Year (${{currentFullYear}})`, data: trimmedCurrYearData, borderColor: colors.curr, fill: false, borderWidth: 3, hidden: false, tension: 0.1, pointRadius: 3, pointBackgroundColor: colors.curr, yAxisID: 'y_storage' }} : null,
            priceAxisAdded ? {{ label: "Weekly Avg Price", data: priceData, borderColor: colors.price, fill: false, yAxisID: 'y_price', hidden: true, tension: 0.1, pointRadius: 2, pointBackgroundColor: colors.price }} : null
        ].filter(Boolean);

        if (myChart) {{ myChart.destroy(); }}
        myChart = new Chart(chartCanvas, {{
            type: 'line', data: {{ labels: labels, datasets: datasets }},
            options: {{ responsive: true, maintainAspectRatio: false, interaction: {{ mode: 'index', intersect: false }}, stacked: false,
                plugins: {{ legend: {{ display: false }}, title: {{ display: true, text: `${{regionDataKey}} Storage Trend`, font: {{ size: 18, weight: 'bold' }}, padding: {{ top: 10, bottom: 20 }} }},
                    tooltip: {{ mode: 'index', intersect: false, callbacks: {{
                        title: function(context) {{ return `Week ${{context[0].label.split(' ')[0]}}`; }},
                        label: function(context) {{ let label = context.dataset.label || ''; if (label) {{ label += ': '; }} if (context.parsed.y !== null) {{ label += context.parsed.y.toFixed(1) + (context.dataset.yAxisID === 'y_price' ? ' $' : ' Bcf'); }} return label; }}
                    }} }}
                }},
                scales: {{ x: {{ title: {{ display: true, text: 'Week of Year' }}, ticks: {{ autoSkip: false, maxRotation: 45, minRotation: 45, callback: function(val, index) {{ const weekNum = parseInt(this.getLabelForValue(val).split(' ')[0]); if (weekNum === 1 || weekNum === 13 || weekNum === 21 || weekNum === 38 || weekNum === 46 || weekNum === 53) {{ return labels[index].split('(')[1].replace(')', ''); }} else if (weekNum % 4 === 0) {{ return weekNum; }} return ''; }} }} }}, ...yAxesConfig }}
            }}
        }});

        let togglesHtml = '';
        myChart.data.datasets.forEach((ds, idx) => {{
            const color = ds.borderColor || '#000';
            if (ds.label && ds.label.includes("(Internal)")) return;
            if (ds.label) togglesHtml += `<label><span class="color-square" style="background:${{color}}"></span><input type="checkbox" data-dataset-index="${{idx}}" ${{myChart.isDatasetVisible(idx) ? 'checked' : ''}}> ${{ds.label}}</label>`;
        }});
        chartTogglesDiv.innerHTML = togglesHtml;
        chartTogglesDiv.style.display = 'flex'; chartTogglesDiv.style.marginTop = '20px';

        chartTogglesDiv.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {{
            checkbox.onchange = (e) => {{
                const index = e.target.dataset.datasetIndex;
                myChart.data.datasets[index].hidden = !e.target.checked;
                myChart.update();
            }};
        }});
    }}

    function updateStoragePriceScatter(region_display_name) {{
        const regionDataKey = region_display_name;
        const scatterCanvas = document.getElementById("scatter-chart");

        if (!regionDataKey || !(regionDataKey in allRegionData)) {{
            if (scatterChart) {{ scatterChart.destroy(); scatterChart = null; }}
            scatterCanvas.getContext("2d").clearRect(0, 0, scatterCanvas.width, scatterCanvas.height);
            return;
        }}

        const graphData = allRegionData[regionDataKey].graph;
        const logFitData = allRegionData[regionDataKey].log_fit;

        const scatterPoints = graphData.map(d => {{
            if (d.hasOwnProperty('Bcf') && d.hasOwnProperty('price') && d.Bcf !== null && d.price !== null) {{
                return {{ x: d.Bcf, y: d.price }};
            }}
            return null;
        }}).filter(Boolean);

        if (scatterChart) {{ scatterChart.destroy(); }}
        scatterChart = new Chart(scatterCanvas, {{
            type: 'scatter',
            data: {{
                datasets: [
                    {{
                        label: `Historical Data`,
                        data: scatterPoints,
                        backgroundColor: colors.scatter_points,
                        borderColor: colors.scatter_points,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                    }},
                    {{
                        type: 'line',
                        label: 'Logarithmic Line of Best Fit',
                        data: logFitData,
                        borderColor: colors.log_fit_line,
                        borderWidth: 2,
                        fill: false,
                        pointRadius: 0,
                        tension: 0.1
                    }}
                ]
            }},
            options: {{
                responsive: true,
                maintainAspectRatio: false,
                plugins: {{
                    title: {{
                        display: true,
                        text: `${{region_display_name}} Storage vs Henry Hub Price`,
                        font: {{ size: 18, weight: 'bold' }}
                    }},
                    tooltip: {{
                        callbacks: {{
                            label: function(context) {{
                                if (context.dataset.type === 'scatter') {{
                                    return `Storage: ${{context.parsed.x.toFixed(1)}} Bcf, Price: ${{context.parsed.y.toFixed(2)}} $`;
                                }} else {{
                                    return `Fit (Storage: ${{context.parsed.x.toFixed(1)}} Bcf, Price: ${{context.parsed.y.toFixed(2)}} $)`;
                                }}
                            }}
                        }}
                    }}
                }},
                scales: {{
                    x: {{
                        type: 'linear',
                        position: 'bottom',
                        title: {{
                            display: true,
                            text: 'Storage Level (Bcf)',
                            font: {{ size: 14, weight: 'bold' }}
                        }},
                        ticks: {{ font: {{ size: 12 }} }}
                    }},
                    y: {{
                        type: 'linear',
                        position: 'left',
                        title: {{
                            display: true,
                            text: 'Henry Hub Weekly Avg Price ($/MMBtu)',
                            font: {{ size: 14, weight: 'bold' }}
                        }},
                        ticks: {{ font: {{ size: 12 }} }}
                    }}
                }}
            }}
        }});
    }}

    function updateBalanceChart() {{
        const ctx = document.getElementById("balance-chart").getContext("2d");
        if (balanceChart) balanceChart.destroy();
        balanceChart = new Chart(ctx, {{
            type: 'line',
            data: {{
                labels: fundyChartData.labels.concat(forecastChartData.labels),
                datasets: [
                    {{
                        label: "Historical CONUS Balance",
                        data: fundyChartData.values,
                        borderColor: "#2980b9",
                        backgroundColor: "rgba(41, 128, 185, 0.2)",
                        fill: false,
                        tension: 0.1,
                    }},
                    {{
                        label: "Forecasted CONUS Balance",
                        data: Array(fundyChartData.labels.length).fill(null).concat(forecastChartData.values),
                        borderColor: "#e67e22",
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.1,
                    }}
                ]
            }},
            options: {{
                responsive: true,
                maintainAspectRatio: false,
                interaction: {{ mode: 'index', intersect: false }},
                plugins: {{
                    title: {{
                        display: true,
                        text: 'CONUS Balance: Historical vs Forecast',
                        font: {{ size: 18, weight: 'bold' }}
                    }}
                }},
                scales: {{
                    y: {{
                        title: {{ display: true, text: 'Balance (Bcf)' }},
                        ticks: {{ font: {{ size: 12 }} }}
                    }},
                    x: {{
                        title: {{ display: true, text: 'Date' }},
                        ticks: {{ maxRotation: 45, minRotation: 45, font: {{ size: 11 }} }}
                    }}
                }}
            }}
        }});
    }}

    function updateDailyChangeChart(selectedStorageName) {{
        const ctx = document.getElementById("daily-change-chart").getContext("2d");
        if (dailyChangeChart) dailyChangeChart.destroy();

        const data = dailyChangeChartData[selectedStorageName];

        if (!data) {{
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            return;
        }}

        dailyChangeChart = new Chart(ctx, {{
            type: 'line',
            data: {{
                labels: data.dates,
                datasets: [{{
                    label: `Daily Storage Change for ${{selectedStorageName}}`,
                    data: data.values,
                    borderColor: '#17a2b8',
                    backgroundColor: 'rgba(23, 162, 184, 0.2)',
                    fill: false,
                    tension: 0.1,
                    pointRadius: 1
                }}]
            }},
            options: {{
                responsive: true,
                maintainAspectRatio: false,
                plugins: {{
                    title: {{
                        display: true,
                        text: `Daily Storage Change for ${{selectedStorageName}}`,
                        font: {{ size: 18, weight: 'bold' }}
                    }},
                    tooltip: {{
                        mode: 'index',
                        intersect: false,
                        callbacks: {{
                            label: function(context) {{
                                return `Change: ${{context.parsed.y.toFixed(2)}}`;
                            }}
                        }}
                    }}
                }},
                scales: {{
                    x: {{
                        type: 'time',
                        time: {{
                            unit: 'month',
                            tooltipFormat: 'MMM D,YYYY',
                            displayFormats: {{
                                month: 'MMM'
                            }}
                        }},
                        title: {{
                            display: true,
                            text: 'Effective Gas Day'
                        }},
                        ticks: {{
                            maxRotation: 45,
                            minRotation: 45
                        }}
                    }},
                    y: {{
                        title: {{
                            display: true,
                            text: 'Daily Storage Change'
                        }}
                    }}
                }}
            }}
        }});
    }}

    function updateNuclearChart() {{
        const ctx = document.getElementById("nuclear-chart").getContext("2d");
        if (nuclearChart) nuclearChart.destroy();

        if (!nuclearGenerationChartData || nuclearGenerationChartData.labels.length === 0) {{
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            return;
        }}

        const datasets = [
            {{
                label: 'Total MW Generated',
                data: nuclearGenerationChartData.mw_values,
                borderColor: '#f39c12',
                backgroundColor: 'rgba(243, 156, 18, 0.2)',
                fill: false,
                tension: 0.1,
                yAxisID: 'y_mw'
            }}
        ];

        if (nuclearGenerationChartData.price_values && nuclearGenerationChartData.price_values.some(val => val !== null)) {{
            datasets.push({{
                label: 'Henry Hub Price ($/MMBtu)',
                data: nuclearGenerationChartData.price_values,
                borderColor: '#9b59b6',
                backgroundColor: 'transparent',
                fill: false,
                tension: 0.1,
                yAxisID: 'y_price'
            }});
        }}

        nuclearChart = new Chart(ctx, {{
            type: 'line',
            data: {{
                labels: nuclearGenerationChartData.labels,
                datasets: datasets
            }},
            options: {{
                responsive: true,
                maintainAspectRatio: false,
                interaction: {{ mode: 'index', intersect: false }},
                plugins: {{
                    title: {{
                        display: true,
                        text: 'U.S. Nuclear Generation Trend & Henry Hub Price',
                        font: {{ size: 18, weight: 'bold' }}
                    }},
                    tooltip: {{
                        mode: 'index',
                        intersect: false,
                        callbacks: {{
                            label: function(context) {{
                                let label = context.dataset.label || '';
                                if (label) {{
                                    label += ': ';
                                }}
                                if (context.parsed.y !== null) {{
                                    label += context.parsed.y.toFixed(2);
                                    if (context.dataset.yAxisID === 'y_mw') {{
                                        label += ' MW';
                                    }} else if (context.dataset.yAxisID === 'y_price') {{
                                        label += ' $';
                                    }}
                                }}
                                return label;
                            }}
                        }}
                    }}
                }},
                scales: {{
                    x: {{
                        type: 'time',
                        time: {{
                            unit: 'month',
                            tooltipFormat: 'MMM D,YYYY',
                            displayFormats: {{
                                month: 'MMM'
                            }}
                        }},
                        title: {{
                            display: true,
                            text: 'Date'
                        }},
                        ticks: {{
                            maxRotation: 45,
                            minRotation: 45
                        }}
                    }},
                    y_mw: {{
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {{
                            display: true,
                            text: 'Total MW Generated',
                            font: {{ size: 14, weight: 'bold' }}
                        }},
                        grid: {{
                            color: '#e0e0e0'
                        }}
                    }},
                    y_price: {{
                        type: 'linear',
                        display: true,
                        position: 'right',
                        title: {{
                            display: true,
                            text: 'Henry Hub Price ($/MMBtu)',
                            font: {{ size: 14, weight: 'bold' }}
                        }},
                        grid: {{
                            drawOnChartArea: false
                        }}
                    }}
                }}
            }}
        }});
    }}

    // --- NEW: Basis Analysis Chart (Plotly) Function ---
    function updateBasisGraph() {{
        const comp = document.getElementById('componentDropdown').value;
        const data = basisData[comp];
        
        if (!data || data.per_year_data.length === 0) {{
            document.getElementById('plot').innerHTML = '<p style="text-align:center;">No data available or insufficient valid data points for this component for any year.</p>';
            document.getElementById('formula').innerHTML = '';
            document.getElementById('forecast_table').innerHTML = '';
            return;
        }}

        let traces = [];

        // Add traces for each year's historical data points and their fit lines
        data.per_year_data.forEach(year_info => {{
            // Scatter points for the year
            traces.push({{
                x: year_info.x, y: year_info.y, mode: 'markers',
                name: `${{year_info.year}}`,
                marker: {{ size: 8, opacity: 0.7, color: year_info.color }}
            }});

            // Fit line for the year
            if (year_info.fit_x && year_info.fit_x.length > 1) {{
                traces.push({{
                    x: year_info.fit_x, y: year_info.fit_y, mode: 'lines',
                    name: `Fit ${{year_info.year}}`,
                    line: {{ color: year_info.color, width: 2, dash: 'dot' }}
                }});
            }}
        }});

        // Add overall fit line
        if (data.overall_fit_x && data.overall_fit_x.length > 1) {{
            traces.push({{
                x: data.overall_fit_x, y: data.overall_fit_y, mode: 'lines',
                name: `Overall Quadratic Fit`,
                line: {{ color: 'black', width: 3 }}
            }});
        }}

        // If basisPlotlyChart exists, recreate it with new data, otherwise create new
        if (basisPlotlyChart) {{
            Plotly.newPlot('plot', traces, {{
                title: {{ text: `${{comp}} Basis vs. ${{data.city}} Avg Temp`, font: {{ size: 20 }} }},
                xaxis: {{ title: 'Average Temperature (¬∞F)', automargin: true }},
                yaxis: {{ title: 'Daily Basis ($/MMBtu)', automargin: true }},
                hovermode: 'closest',
                margin: {{ l: 50, r: 50, b: 80, t: 80, pad: 4 }},
                plot_bgcolor: '#fcfcfc',
                paper_bgcolor: '#fcfcfc',
                showlegend: true,
                legend: {{ x: 1.02, y: 1, xanchor: 'left', yanchor: 'top' }},
                shapes: [
                    {{
                        type: 'line',
                        xref: 'paper', yref: 'y',
                        x0: 0, y0: 0, x1: 1, y1: 0,
                        line: {{ color: 'grey', width: 1, dash: 'dot' }}
                    }}
                ]
            }});
        }} else {{
            basisPlotlyChart = Plotly.newPlot('plot', traces, {{
                title: {{ text: `${{comp}} Basis vs. ${{data.city}} Avg Temp`, font: {{ size: 20 }} }},
                xaxis: {{ title: 'Average Temperature (¬∞F)', automargin: true }},
                yaxis: {{ title: 'Daily Basis ($/MMBtu)', automargin: true }},
                hovermode: 'closest',
                margin: {{ l: 50, r: 50, b: 80, t: 80, pad: 4 }},
                plot_bgcolor: '#fcfcfc',
                paper_bgcolor: '#fcfcfc',
                showlegend: true,
                legend: {{ x: 1.02, y: 1, xanchor: 'left', yanchor: 'top' }},
                shapes: [
                    {{
                        type: 'line',
                        xref: 'paper', yref: 'y',
                        x0: 0, y0: 0, x1: 1, y1: 0,
                        line: {{ color: 'grey', width: 1, dash: 'dot' }}
                    }}
                ]
            }});
        }}

        document.getElementById('formula').innerHTML = `<b>Overall Best Fit Formula (Quadratic):</b> ${{data.overall_formula}}`;

        // --- Populate Forecast Table ---
        const forecastTableDiv = document.getElementById('forecast_table');
        const forecastDataForComp = data.forecast_table_data;

        if (forecastDataForComp && forecastDataForComp.length > 0) {{
            let tableHtml = '<h3>7-Day Basis Forecast (using Overall Quadratic Fit)</h3>';
            tableHtml += '<table><thead><tr><th>Date</th><th>Forecast Temp (¬∞F)</th><th>Predicted Basis ($/MMBtu)</th></tr></thead><tbody>';
            forecastDataForComp.forEach(row => {{
                tableHtml += `<tr><td>${{row.Date}}</td><td>${{row['Avg Temp'].toFixed(1)}}</td><td>${{row['Predicted Basis'].toFixed(3)}}</td></tr>`;
            }});
            tableHtml += '</tbody></table>';
            forecastTableDiv.innerHTML = tableHtml;
        }} else {{
            forecastTableDiv.innerHTML = '<p style="text-align:center;">No 7-day forecast data available or fit not possible for this component.</p>';
        }}
    }}

    document.addEventListener("DOMContentLoaded", function() {{
        const storageRegionSelect = document.getElementById("region-select");
        storageRegionSelect.value = ""; // Ensures "Choose Region" is displayed for storage tab

        const reportRegionSelect = document.getElementById("report-region-select");
        reportRegionSelect.value = defaultRegion; // Set default region for the report tab
        
        reportRegionSelect.addEventListener("change", function() {{
            updateReportContent(this.value);
        }});

        document.getElementById("region-select").addEventListener("change", function() {{
            const selectedRegion = this.value;
            const currentActiveTab = document.querySelector('.tab.active');
            if (currentActiveTab && currentActiveTab.id === 'storage-info') {{
                if (selectedRegion && selectedRegion !== "") {{
                    updateEIAStorageGraph(selectedRegion);
                    updateStoragePriceScatter(selectedRegion);
                }} else {{
                    if (myChart) {{ myChart.destroy(); myChart = null; }}
                    if (scatterChart) {{ scatterChart.destroy(); scatterChart = null; }}
                    document.getElementById("chart").getContext("2d").clearRect(0, 0, document.getElementById("chart").width, document.getElementById("chart").height);
                    document.getElementById("scatter-chart").getContext("2d").clearRect(0, 0, document.getElementById("scatter-chart").width, document.getElementById("scatter-chart").height);
                    document.getElementById("chart-legend-toggles").innerHTML = "<p><em>Select a region from the dropdown above to view its storage graphs.</em></p>";
                    document.getElementById("chart-legend-toggles").style.display = 'block';
                }}
            }}
        }});

        document.getElementById("daily-change-select").addEventListener("change", function() {{
            const selectedStorageName = this.value;
            const currentActiveTab = document.querySelector('.tab.active');
            if (currentActiveTab && currentActiveTab.id === 'daily-changes') {{
                if (selectedStorageName) {{
                    updateDailyChangeChart(selectedStorageName);
                }} else {{
                    if (dailyChangeChart) {{ dailyChangeChart.destroy(); dailyChangeChart = null; }}
                    document.getElementById("daily-change-chart").getContext("2d").clearRect(0, 0, document.getElementById("daily-change-chart").width, document.getElementById("daily-change-chart").height);
                }}
            }}
        }});

        // NEW: Event listener for Basis Analysis dropdown
        document.getElementById("componentDropdown").addEventListener("change", function() {{
            const currentActiveTab = document.querySelector('.tab.active');
            if (currentActiveTab && currentActiveTab.id === 'basis-analysis') {{
                updateBasisGraph();
            }}
        }});

        showTab('report'); // Show report tab by default
    }});
</script>
</body>
</html>
"""

    # --- Generate and Open HTML Report ---
    try:
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(html_template_raw)
        print(f"\n‚úÖ HTML dashboard successfully generated at: {output_path}")
        webbrowser.open(f"file:///{output_path}")
    except Exception as e:
        print(f"‚ùå Failed to write HTML dashboard: {e}")